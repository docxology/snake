# Algorithm Overview

The Snake-in-the-Box package implements the **heuristically-pruned breadth-first search** algorithm from Ace (2025), which discovered new lower bounds of 732, 1439, and 2854 in 11, 12, and 13 dimensions, respectively.

## Problem Statement

The Snake-in-the-Box problem seeks to find the longest possible **induced path** in an n-dimensional hypercube graph Q_n. An induced path has the constraint that no two non-consecutive vertices may be adjacent to each other on the hypercube.

### Key Constraints

1. **Consecutive vertices** must differ in exactly one bit (Hamming distance = 1)
2. **Non-consecutive vertices** must differ in more than one bit (Hamming distance > 1)

This constraint distinguishes snake-in-the-box from simpler longest path problems and makes it computationally challenging.

## Algorithm Approach

The algorithm performs a **level-by-level expansion** of a search tree:

1. **Search Tree Structure**: Each node represents a snake (transition sequence) and the hypercube state
2. **Breadth-First Expansion**: Explores all nodes at a given level before moving to the next
3. **Heuristic Pruning**: When memory limits are exceeded, nodes are pruned based on fitness
4. **Memory Management**: Only two levels are kept in memory at once
5. **Canonical Form**: Uses Kochut's canonical form to eliminate symmetric solutions

## Algorithm Components

### 1. Search Tree Representation

The search tree is organized with:
- **Root**: Empty snake at origin (vertex 0)
- **Nodes**: Each node contains a transition sequence and hypercube bitmap
- **Children**: Generated by extending the snake in valid directions

### 2. Pruning Strategy

When memory limits are exceeded:
- Nodes are sorted by fitness (unmarked vertex count)
- Top nodes within memory limit are kept
- Lower-fitness nodes are discarded

### 3. Canonical Form

Kochut's canonical form reduces search space by:
- Requiring first transition to be 0
- Limiting subsequent transitions to ≤ max_dimension_used + 1
- Eliminating symmetric solutions

### 4. Priming Strategy

For high dimensions (9+), the algorithm:
- Starts from known good snakes in lower dimensions
- Extends them to higher dimensions
- Makes search tractable for high-dimensional spaces

## Performance Characteristics

- **Time Complexity**: Exponential in worst case, pruned by heuristics
- **Memory**: O(beam_width × node_size) where beam_width is determined by memory limits
- **Typical Performance** (from paper):
  - Dimension 10: 50 minutes (Intel i5-12600K, 18GB, 10 threads)
  - Dimension 13: 2 hours (19GB memory)

## Algorithm Flow

See [Pruned BFS Algorithm](pruned-bfs.md) for detailed step-by-step description.

## Related Documentation

- [Pruned BFS Algorithm](pruned-bfs.md) - Detailed algorithm implementation
- [Canonical Form](canonical-form.md) - Symmetry reduction
- [Priming Strategy](priming-strategy.md) - High-dimensional search
- [Fitness Evaluation](fitness-evaluation.md) - Pruning heuristics
- [Algorithm Flow Diagram](../diagrams/algorithm-flow.md) - Visual flowchart

## Reference

Ace, Thomas E. "New Lower Bounds for Snake-in-the-Box in 11-, 12-, and 13-dimensional Hypercubes." (2025) doi:10.5281/zenodo.17538015

